// external
use pyo3::prelude::*;
use rand::Rng;

use crate::misc::hist_memory;
use crate::components::tms_engine::TMSEngine;
use crate::components::generic_storage::GenericStorage;

#[pyclass]
#[derive(Clone)]
pub struct TMS {
    #[pyo3(get)]
    pow_e: f32,  // electrical power of tms plant [W]
    #[pyo3(get)]
    pow_t: f32,  // installed power of tms plant [W]
    #[pyo3(get)]
    tms_engine: TMSEngine, // tms engine
    #[pyo3(get)]
    pressure_tanks: GenericStorage,  // HP/LP tanks in one storage
    #[pyo3(get)]
    gen_t: Option<hist_memory::HistMemory>,
    #[pyo3(get)]
    gen_e: Option<hist_memory::HistMemory>,
}

#[pymethods]
impl TMS {
    ///  Create TMS plant
    ///
    /// # Arguments
    /// * power_t (f32): installed thermal tms power [W]
    /// * engine: teh engine being used, must be defined beforehand
    /// * pressure_tanks: Storage formed by HP-LP tanks, must be defined before hand
    /// * hist (usize): Size of history memory (0 for no memory)
    #[new]
    pub fn new(power_t: f32, engine: TMSEngine, pressure_tanks: GenericStorage, hist: usize) -> Self {

        if power_t < 0. {
            panic!("Installed thermal power of tms \
                    must be greater than 0")
        }

        let pow_t = power_t;
        let pow_e = 0.5 * pow_t;

        let state = false;

        let (gen_e, gen_t) =
            if hist > 0 {
                (Some(hist_memory::HistMemory::new(hist)),
                 Some(hist_memory::HistMemory::new(hist)))
            } else {
                (None, None)
            };

        TMS {pow_e,
             pow_t,
             engine,
             pressure_tanks,
             gen_e,
             gen_t,
             }
    }
}

/// TMS plant
impl TMS {
    /// Calculate the fuel power needed to provide given electrical and thermal
    /// power.
    ///
    /// # Arguments
    /// * pow_e (f32): electrical power generated by chp [W]
    /// * pow_t (f32): thermal power generated by chp [W]
    ///
    /// # Returns
    /// f32: Power of fuel needed to provide given electrical and
    ///      thermal power [W]s

    // Control Parameter
    const STORAGE_LEVEL_HH: f32 = 0.95;
    const STORAGE_LEVEL_H: f32 = 0.3;
    const STORAGE_LEVEL_L: f32 = 0.2;
    const STORAGE_LEVEL_LL: f32 = 0.05;

    fn control(&mut self){
        let storage_state = self.pressure_tanks.get_relative_charge();

        if storage_state <= TMS::STORAGE_LEVEL_LL {
            self.tms_engine.state = true;
            self.tms_engine.direction_state = false;
        }
        else if (storage_state <= TMS::STORAGE_LEVEL_L) {
            self.tms_engine.state = true;
            self.tms_engine.direction_state = false;
        }
        else if (storage_state >= TMS::STORAGE_LEVEL_H) {
            self.tms_engine.state = true;
            self.tms_engine.direction_state = false;
        }
        else if storage_state >= TMS::STORAGE_LEVEL_HH {
            self.tms_engine.state = false;
            self.tms_engine.direction_state = true;
        }
    }

    fn save_hist(&mut self, pow_e: &f32, pow_t: &f32, fuel_used: &f32) {
        match &mut self.gen_e {
            None => {},
            Some(gen_e) => {
                gen_e.save(*pow_e)
            },
        }
        match &mut self.gen_t {
            None => {},
            Some(gen_t) => {
                gen_t.save(*pow_t)
            }
        }
    }

    /// Calculate current electrical and thermal power
    ///
    /// # Arguments
    /// * state (&bool): Current state of TMS plant (on/off)
    /// * direction_state (&bool): Current direction (charging/discharging) of TMS plant
    ///
    /// # Returns
    /// * (f32, f32, f32): Resulting electrical and thermal power and fuel used [W]
    pub fn step(&mut self, state: &bool) -> (f32, f32) {

        // update state
        self.engine.state = *state;

        // calculate power output
        let pow_t;
        let pow_e;
        if self.state {
            pow_t = self.pow_t;
            pow_e = self.pow_e;
        }
        else {
            pow_t = 0.0;
            pow_e = 0.0;
        }

        // save and return data
        self.save_hist(&pow_e, &pow_t);

        return (pow_e, pow_t);
    }
}